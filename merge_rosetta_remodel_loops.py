#!/usr/bin/env python
#
# Merges loops generated by Rosetta remodel into an "original" protein structure.
#
# Looks for the generated loop PDBs in the same directory as each scorefile. You are explicitly allowed
# to specify multiple scorefiles, each in a separate directory.
#
# Usage:
#     <original-pdb> <scorefile> [scorefile...]
import argparse
import os
import sys
import re
import glob
import MDAnalysis as mda
from rosetta_loopmodeling_remodel_blueprint import PDBEmitter


class ResidueNode(object):
    def __init__(self, resid, is_loop=False, name=None):
        self.resid = resid
        self.is_loop = is_loop
        self.name = name
        self.next = None

    def insert_after(self, node):
        node.next = self.next
        self.next = node


class ClippableInterval(object):
    """Intervals are of integers only, inclusive of its left and right sides. So Interval(1, 3) spans 3 integers. """
    def __init__(self, left, right):
        # Construct a linked list, one template residue per node
        is_first_node = True
        for i in range(left, right+1):
            node = ResidueNode(i)
            if is_first_node:
                self.head = node
                is_first_node = False
            else:
                prev_node.next = node
            prev_node = node

        self.loops = {}

    def insert(self, left, right, name):
        # Check if this interval overlaps any previous loops
        # if name in self.loops:
        #     raise Exception('New loop %s has same name as existing one' % name)
        # for k in self.loops:
        #     l0, r0 = self.loops[k]
        #     if (left >= l0 and left <= r0) or (right >= l0 and right <= r0):
        #         raise Exception('New loop %s: (%d, %d) overlaps existing loop %s: (%d, %d)' % (name, left, right,
        #             k, l0, r0))

        # Iterate through linked list until we hit the template resid we want
        ptr = self.head
        # FIXME: Does not support N-terminal loop
        prev_ptr = None
        while ptr:
            if not ptr.is_loop and ptr.resid == left:
                if prev_ptr is None:
                    raise Exception('I am not smart enough to handle an N-terminal loop')
                # Excise this and the next node because we want the loop to replace them
                after = ptr.next.next
                ptr = prev_ptr
                ptr.next = after
                # Insert a new node for each loop residue
                for i in range(left, right):
                    node = ResidueNode(i, is_loop=True, name=name)
                    node.next = ptr.next
                    ptr.next = node
                    ptr = node
            prev_ptr = ptr
            ptr = ptr.next

        # print >>sys.stderr, 'Added %s (%d, %d)' % (name, left, right)


def all_coordinates_are_unique(u):
    """Returns True if all atom coordinates in MDAnalysis Universe u are unique.

    If they are not unique, something is wrong!"""
    return len(set([tuple(a.position) for a in u.atoms])) == len(u.atoms)

# Don't think we need this anymore
def best_pdb_in_scorefile(fname):
    lines = open(fname, 'r').readlines()
    # Ignore the header line, in an extremely inefficient manner
    lines = filter(lambda l: 'total_score' not in l, lines)
    lines = filter(lambda l: l.startswith('SCORE:  '), lines)
    tokenized_lines = [l.split() for l in lines]
    tokenized_lines = filter(lambda t: float(t[1]) > 0.0, tokenized_lines)

    scores = []
    for tokens in tokenized_lines:
        score = tokens[1]
        pdb = '%s.pdb' % tokens[-1]
        scores.append((score, pdb))

    # At this point, we have the scores.
    scores = sorted(scores, reverse=True)
    best_score, loop_pdb = scores[0]
    if best_score == 0:
        return None
    return loop_pdb


def loop_bounds_from_blueprint(fname):
    # Get name of loopXXX_YY directory name the blueprint file is in, to guess loop bounds
    # Extract the loop spec
    lines = open(fname, 'r').readlines()
    lines = filter(lambda l: 'PIKAA' in l, lines)
    # Now we know where the loop should go in the template
    # The first and last lines that include PIKAA are the rosetta loop bounds
    rosetta_loop_start, rosetta_loop_len = int(lines[0].split()[0]), len(lines)
    return rosetta_loop_start, rosetta_loop_len


def load_remodel_conf(fname):
    """Loads Rosetta Remodel configuration file, which is just key/value pairs, and return as a dict."""
    d = dict()
    conf_re = re.compile(r'-(.+?)\s+(.*)$')
    with open(fname) as f:
        lines = f.readlines()
        for line in lines:
            line = line.strip()
            if line == '':
                continue
            m = conf_re.match(line)
            if m is None:
                print line
            d[m.group(1)] = m.group(2)

    return d


def main():
    ap = argparse.ArgumentParser(description='Merge back generated loops from rosetta_loopmodeling_remodel_blueprint.py')
    ap.add_argument('remodel_confs', nargs='+', help='Rosetta remodel configuration files')
    args = ap.parse_args()

    template_conf_fname = args.remodel_confs[0]
    template_conf = load_remodel_conf(template_conf_fname)
    template_blueprint_dir = os.path.abspath(os.path.dirname(template_conf_fname))
    template_u = mda.Universe('%s/%s' % (template_blueprint_dir, template_conf['in:file:s']))
    # This template is the renumbered protein. Load the resid mapping
    map_lines = open('%s/../%s' % (template_blueprint_dir, 'real-to-rosetta-resid.map')).readlines()
    rosetta_to_real_resid = {}
    for line in map_lines:
        real, rosetta = [int(x) for x in line.split()]
        rosetta_to_real_resid[rosetta] = real
    which_one = ClippableInterval(1, template_u.atoms.n_residues)
    # TODO: Ensure n_residues == largest resid

    bp_re = re.compile(r'loop(\d+)_(\d+)$')
    for fname in args.remodel_confs:
        conf = load_remodel_conf(fname)
        if conf['in:file:s'] != template_conf['in:file:s']:
            print >>sys.stderr, 'Template PDB file differs in %s.' % fname
            exit(1)
        # loop_start is with respect to original, real resids.
        # rosetta_loop_start is with respect to the renumbering we had to do for Rosetta
        blueprint_dir = os.path.abspath(os.path.dirname(fname))

        # Match only on last part of absolute directory, which should be of the form loopXXX_YY
        m = bp_re.match(os.path.split(blueprint_dir)[1])
        loop_start, loop_len = int(m.group(1)), int(m.group(2))
        rosetta_loop_start, rosetta_loop_len = loop_bounds_from_blueprint('%s/%s' % (blueprint_dir, conf['remodel:blueprint']))
        if rosetta_loop_len != (loop_len + 2):
            print >> sys.stderr, 'With %d residues missing from the template, we should have %d residues in the new loop' % \
                                 (loop_len, loop_len + 2)
            print >> sys.stderr, 'But instead we have %d residues in the new loop. What gives?' % rosetta_loop_len
        scorefiles = glob.glob('%s/*.sc' % blueprint_dir)
        # assert len(scorefiles) == 1, 'Too many scorefiles in %s. I dunno how to deal with that yet' % blueprint_dir
        if len(scorefiles) != 1:
            print >>sys.stderr, 'There are %d scorefiles in %s, so skipping it' % (len(scorefiles), blueprint_dir)
            continue
        # Find the Rosetta-generated loop with the best score
        # loop_pdb = best_pdb_in_scorefile(scorefiles[0])
        loop_pdb = '1.pdb'
        loop_pdb = os.path.join(blueprint_dir, loop_pdb)
        if not os.path.isfile(loop_pdb):
            print >>sys.stderr, 'No 1.pdb in %s, so skipping it' % blueprint_dir
            continue
            
        # Loop_len is just the missing part. Rosetta_loop_len includes the flanking residues.
        # Therefore, rosetta_loop_len == loop_len + 2
        print >>sys.stderr, loop_start, loop_len, '->', rosetta_loop_start, rosetta_loop_len
        print >>sys.stderr, loop_pdb

        which_one.insert(rosetta_loop_start, rosetta_loop_start + rosetta_loop_len, loop_pdb)

    out_fname = 'merged_%dloops.pdb' % len(args.remodel_confs)
    emitter = PDBEmitter(open(out_fname, 'w'))
    universes = {'template': template_u}

    ptr = which_one.head
    global_resid = 1
    loop_offset = 0
    while ptr:
        pdb = ptr.name or 'template'
        if pdb not in universes:
            universes[pdb] =  mda.Universe(pdb)

        residue = universes[pdb].select_atoms('resid %d' % ptr.resid)
        occupancy = 0.0 if pdb == 'template' else 1.0
        # Restore native residue numbering, since we had to jack it all up for the sake of Rosetta
        if ptr.name: # and ptr.name.startswith('loop'):
            m = bp_re.match(os.path.split(os.path.split(ptr.name)[0])[1])
            curr_resid, _ = int(m.group(1)), int(m.group(2))
            curr_resid += loop_offset
            loop_offset += 1
        else:
            curr_resid = rosetta_to_real_resid[ptr.resid]
            loop_offset = 0

        for a in residue.atoms:
            emitter.emit_atom(a, occupancy=occupancy, resid=curr_resid)

        print 'HELLO', ptr.resid, curr_resid, ptr.name

        ptr = ptr.next
        global_resid += 1

    print >>sys.stderr, 'Wrote output PDB to %s.' % out_fname


if __name__ == '__main__':
    main()
